rm(list = ls())

#"Ctrl + Invio" esegue il comando che si trova sulla riga della console oppure 
#tutti i comandi contenuti in una selezione di più righe

x <- 10


2 + 2 
#in realtà è una funzione, può anche essere scritto come:
'+'(2, 2)


##OPERATORI LOGICI
3 > 4 & 10 < 100 # & AND
10 < 100 | 50 > 2 # | OR

#ESERCIZI 1.1 Operazioni matematiche
((45+21)^3 + 3 / 4)/sqrt(32 - (12 / 17))
(sqrt(7 - pi)) / (3 *(45 - 34))
(12 - (exp(1)^2))^ (1/3) + log(10*pi)
((sin((3/4)*pi)^2)+cos((3/2)*pi))/log(exp(1)^(3/2), base = 7)
sum(1:10)/10

## OGGETTI

2 #numero
"2" #stringa, qualsiasi cosa tra virgolette viene interpretata come stringa
ciao #nome | I nomi vanno prima dichiarati: ciao <- "saluto"

#le stringhe vengono in automatico convertite in un numero che indica
#la posizione delle lettere nell'alfabeto

"a" < "b"
"a" > "b"

#R è case-sensitive quindi le maiuscole e le minuscole non coincidono

"A" == "a"

#ESERCIZI 1.2 Operazioni logiche
(x%%2) == 0 #pari
(x%%2) != 0 #dispari
(x > -4) & (x < -2) | (x > 2) & (x < 4) 
4 ^ 3 %in% c(2,3,4) #restituisce false perchè la potenza prevale sull'operatore logico
4 * 3 %in% c(2,3,4) #resctituisce un numero perchè prima viene eseguito l'operatore
#logico la cui risposta è TRUE, il TRUE vale 1, quindi, 4 * 1 = 4
"ciao" == "ciao" #TRUE
"R" == "r" #FALSE
"SPSS" != "SpSS" #TRUE
"1" == 1 #TRUE; quando viene fatto un confronto tra due oggetti incompatibili R tenta
# di trasformare gli oggetti in oggetti compatibili, tendenzialmente viene trasformato 
# tutto in stringa
"1" > "ciao" #FALSE; attenzione che qui l'1 è letto come stringa
"a" > "b" # FALSE
"ciao" > "zebra" #FALSE



#SELEZIONE
my_vec <- rnorm(10, mean = 5, sd = 2.5)
my_selection <- my_vec < 2 | my_vec > 8
my_vec[my_selection]

my_vec[my_vec < 2 | my_vec > 8] # in modo più compatto

#posso anche usare la funzione which con la quale posso estrarre le posizioni

whichselection <- which(my_vec < 2 | my_vec > 8)
my_vec[whichselection]

#ESERCIZI 2.1.1 Operazioni matematiche
x <- c(4, 6, 12, 34)
y <- seq(from = 2, to = 24, by = 2)
z <- seq(from = 14, length.out = 10, by = 7)
s <- rep(c("A", "B", "C"), times = 4)
t <- rep(c("A", "B", "C"), each = 4)
rep(rep(c("foo", "bar"), each = 2), 2)

#ESERCIZI 2.1.2 Indicizzare vettori
x[c(2, 3, 5)]
x[x == 34 | x == 4]
my_vector = c(2,4,6,8)
my_vector[my_vector]
#dal vettore si cercano di estrarre le posizioni 2 e 4, che esistono, 6 e 8, che non esistono
y [y < 13 | y > 19]
z[z >= 24 & z >= 50]
s[s == "A"]
t[!t == "B"]
u <- s
u[u == "A"] <- "U" # oppure u <- replace(s, s == "A", "U")
u
z <- z[!z == 28 | z == 42]

id <- sample(1:10, 1)
string <- paste(letters[c(sample(1:26,size = 5))], collapse = "")
num <- sample(100:999, 1)
paste(c(id, string, num), collapse = "_")


#ESERCIZI 2.2 FATTORI
genere <- c("M", "F", "M", "F", "M", "F", "F", "F", "M")
genere <- factor(genere)
genere <- factor(genere, labels = c("donne", "uomini"), levels = c("donne", "uomini"))

intervento <- factor(c(rep(c("CBT","Psicanalisi"),3),"Controllo","Controllo","CBT"))
intervento <- factor(c(rep(c("CBT","Psicanalisi"),3),"Controllo","Controllo","CBT"),
                     levels = c("CBT", "Controllo", "Psicanalisi", "Farmaci"))
intervento[c(7, 8)] <- "Farmaci"
intervento <- factor(intervento, levels = c("CBT", "Farmaci", "Psicanalisi")) #da correggere
intervento[c(10:12)] <- c("CBT", "Farmaci", "Psicanalisi") #da correggere


#ESERCIZI 2.4 LISTE
#1
lista1 <- list(1:100,
     letters[1:15],
     seq(from = 10, to = 100, by = 2),
     c("aa", "bb"))
names(lista1) <- c("x", "y", "B", "lett")
#per dare direttamente il nome:
lista1 <- list(x = 1:100,
               y = letters[1:15],
               B = seq(from = 10, to = 100, by = 2),
               lett = c("aa", "bb")               )
#2
lista1$test_x <- lista1$x%%2 == 0
#3
lista1$selection_x <- c(lista1$x[lista1$test_x])
#4
lista1$y <- rep(lista1$y, each = 4)
#5
lista1$x[lista1$x <= 50]
#6
lista1$lista2 <- lista1[1:3]
#7
lista1$lista2$x_div_3 <- lista1$x[lista1$x%%3 == 0]
    
    
#IMPORTAZIONE DATI

#FILE CSV
dat <- read.csv(file = "extra/data/csv_example.csv",
         header = TRUE,
         sep = ",")

dat <- read.csv(file = "extra/data/csv_example.csv",
                header = FALSE, #con questo errore tutte le variabili verranno 
                                #considerate come caratteri
                sep = ",")

#a volte bisogna indicare a R quale dato interpretare come NA perchè i diversi
#software possono gestire diversamente le celle vuote

readxl::read_xlsx(path = "extra/data/excel_example.xlsx")


#ESERCIZI 2.5

#1
data_long<-data.frame(Id=rep(c("subj_1","subj_2","subj_3"),each=3),
                      age=rep(c(21,23,19),each=3),
                      gender=rep(c("F","M","F"),each=3),
                      item=rep(1:3,3),
                      response=c(2,1,1,0,2,1,2,0,1))
#2
data_example <- readRDS(file = "exercises/data/dataframe_example1.rds")
data_example[data_example$age > 30, ]
data_example[data_example$age > 30 | data_example$age < 21, ]
data_example[data_example$degree == "dams" & data_example$degree_score > 100 & data_example$number_siblings >= 1, ]
data_example[data_example$degree == "psicologia" & data_example$number_siblings == 0, ]
data_example[data_example$depression > 50 & data_example$anxiethy > 20, ]

#3
put_random_na <- function(data, n){
    
    pos <- list(rows = 1:nrow(data),
                cols = 1:ncol(data))
    
    pos <- expand.grid(pos)
    
    na_pos <- sample(1:nrow(pos), n)
    
    for (i in 1:length(na_pos)) {
        
        na_pos_i <- pos[na_pos[i], ]
        
        data[na_pos_i[[1]], na_pos_i[[2]]] <- NA
        
    }
    
    return(data)
}
data_example <- put_random_na(data_example, 20)
data_example[is.na(data_example$degree) | is.na(data_example$age), ]
data_example[is.na(data_example$email) & ( data_example$region == "Veneto" | data_example$region == "Campania"  ), ]
data_example[complete.cases(data_example), ]

#4
head(df_esercizio4)
df_esercizio4 <- read.csv(file = "exercises/data/dataframe_example2.csv")
df_esercizio4$id <- c(1:500)
is.character(df_esercizio4$nome)      #ok
is.character(df_esercizio4$cognome)   #ok
is.numeric(df_esercizio4$phone)       #FALSE
df_esercizio4$phone <- gsub(pattern = "-", replacement = "",x = df_esercizio4$phone)
df_esercizio4$phone <- gsub(pattern = "\\(", replacement = "",x = df_esercizio4$phone)
df_esercizio4$phone <- gsub(pattern = " ", replacement = "",x = df_esercizio4$phone)
df_esercizio4$phone <- as.numeric(df_esercizio4$phone) #perchè non riesco a trasformarli in integer?
is.numeric(df_esercizio4$phone)             #ok
is.character(df_esercizio4$email)           #ok
is.character(df_esercizio4$region)          #ok
is.numeric(df_esercizio4$age)               #ok
is.character(df_esercizio4$colore)          #ok
is.character(df_esercizio4$festa_preferita) #ok
is.numeric(df_esercizio4$id)                #ok
df_esercizio4[df_esercizio4$festa_preferita == "nessuna", ] #ggiustare caratteri
df_esercizio4$festa_preferita <- tolower(df_esercizio4$festa_preferita)
df_esercizio4[df_esercizio4$festa_preferita == "nessuna", ]
df_esercizio4[df_esercizio4$colore == "blu" & df_esercizio4$festa_preferita == "natale", ] #piace blu e natale
subset(df_esercizio4, select = sapply(df_esercizio4, is.numeric)) #grazie chatGPT

##ESERCIZI 3 PROGRAMMAZIONE
#3.1.1
convert_ftoc <- function(fahr_dg){
    (fahr_dg * 1.8) + 32
}

#3.1.2
buon_natale <- function(nome){
    print(paste("CarƏ", nome, "tanti auguri di Buon Natale a te e famiglia"))
}
buon_natale("Giulio")

#3.1.3

n_and_media <- function(x){
    lunghezza_di_x <- length(x)
    media_di_x <- mean(x)
    paste("La media di", deparse(substitute(x)), "è", round(media_di_x, 2), ", la lunghezza è", lunghezza_di_x)
}
Età <- round(rnorm(694, 40, 15))
n_and_media(Età)

#3.2.1

calcolo_voto <- function(punteggio){
    dplyr::case_when(
    punteggio < .55 ~ "insufficiente",
    punteggio >= .55 & punteggio < .65 ~ "sufficiente",
    punteggio >= .65 & punteggio < .75 ~ "buono",
    punteggio >= .75 & punteggio < .85 ~ "distinto",
    punteggio >= .85 & punteggio <= 1 ~ "ottimo",
    TRUE ~ "Error") 
}

#3.2.2
calcolo_voto_ifelse <- function(punteggio){
    ifelse(punteggio < .55,
           yes = "insufficiente",
           no = ifelse(
               punteggio >= .55 & punteggio < .65,
               yes = "sufficiente",
               no = ifelse(
                   punteggio >= .65 & punteggio < .75,
                   yes = "buono",
                   no = ifelse(
                       punteggio >= .75 & punteggio < .85,
                       yes = "distinto",
                       no = ifelse(
                           punteggio >= .85 & punteggio <= 1,
                           yes = "ottimo",
                           no = "Error")))))
}
score_chr <- calcolo_voto(1)

#3.2.3

pod <- function(punteggio){
    dplyr::case_when(
        punteggio%%2 == 0  ~ "pari",
        !punteggio%%2 == 0  ~ "dispari",
        TRUE ~ "Error") 
}

#3.2.4
multipli <- function(punteggio){
    mult_3 <- dplyr::case_when(
        punteggio%%3 == 0  ~ TRUE,
        TRUE ~ FALSE) 
    if(mult_3 == TRUE){ print("Il tuo numero è multiplo di 3")}
    mult_4 <- dplyr::case_when(
        punteggio%%4 == 0  ~ TRUE,
        TRUE ~ FALSE)  
    if(mult_4 == TRUE) {print("Il tuo numero è multiplo di 4")}
    mult_5 <- dplyr::case_when(
        punteggio%%5 == 0  ~ TRUE,
        TRUE ~ FALSE)  
    if(mult_5 == TRUE) {print("Il tuo numero è multiplo di 5")}
    if(mult_3 == FALSE & mult_4 == FALSE & mult_5 == FALSE ) {print("Il tuo numero non è multiplo né di 3, né di 4, né di 5")}
}

#3.3.1 Scrivi un loop che scorre le colonne del dataset iris (lo trovate direttamente in R) e stampa il nome della colonna assieme al numero di caratteri che compone la stringa. Ad esempio Sepal.Length (12). Potete usare le funzioni print(), paste() and nchar().
for (i in 1:ncol(iris)) {

    print(paste(names(iris [i]), " (",nchar(names(iris [i])), ")", sep = ""))
    rm(i)
}


#3.3.2

for (i in 1:ncol(iris)){
    
        if(is.numeric(iris[, i]) == TRUE ){print(mean(iris [, i]))}
        else {print(table(iris [, i]))}
    }

#3.3.3

apply(mtcars, 2, sd)

#3.3.4
my_mat <- matrix(NA, 10, 10) # matrice vuota 10x10
for (i in 1:length(my_mat)){
    my_mat[i] <- rnorm(1)
    
    }
#OPPURE
for (r in 1:nrow(my_mat)){
    for ( c in 1:ncol(my_mat)) {
        my_mat[r, c] <- rnorm(1)
    }
}

#3.4.1 SOMMA
x <- rnorm(100)

sommatoria <- function(x){
    c <- 0
    for (n in 1:length(x)) {
        c <- c + x[n]}
    as.numeric(paste(c))   
    }
sommatoria(x)

#3.4.2 MEDIA
media <- function(x){
    sommatoria(x) / length(x)
}
media(x)
mean(x)

#3.4.3 MEDIANA
mediana <- function(x){
    if(length(x)%%2 == 0) {
        (x[(length(x)/2) + 1] +  x[length(x)/2])/2
    }
    else {(length(x)+1)/2}    
}

ogg <- 1:100

#3.4.4 MODA
table(x) #frequenze
max(table(x)) # ripetizioni massime
table(x)[table(x) == max(table(x))] #estrai le mode

moda <- function(x){
   y <- table(x)[table(x) == max(table(x))]
   as.numeric(names(y))
}
x <- round(rnorm(100, 50, 10))
moda(x)

#3.4.5 Deviazione standard

deviazione_standard <- function(x, campione = TRUE, na.rm = FALSE){
    if(na.rm){
        x <- x[!is.na(x)] 
    }
    if(campione){
    devianza <- sommatoria((x - mean(x, na.rm = na.rm))^2)
    varianza <- devianza / (length((x - mean(x, na.rm = na.rm)))-1)
    sqrt(varianza)
    } else {
        devianza <- sommatoria((x - mean(x, na.rm = na.rm))^2)
        varianza <- devianza / (length((x - mean(x, na.rm = na.rm))))
        sqrt(varianza)}
}

deviazione_standard(x, FALSE)

#3.4.6 Trova il numero all’interno del vettore

quante_volte <- function(vettore, bersaglio){
   length( vettore[vettore == bersaglio])
}

#3.4.7 Numeri pari

quali_pari <- function(x){
    recipiente <- c()
    for (i in 1:length(x)){
    if(x[i]%%2 ==0){
        recipiente <- rbind(recipiente, x[i])}
    }
    recipiente[,1]
}

quanti_pari <- function(x){
    length(quali_pari(x))
}

#3.4.8 complete.cases()

complete.cases(iris[1:10, ])

my_complete_cases_pro <- function(x){ #ricrea matrice con logici
    recipiente <- matrix(NA, nrow(x), ncol(x))
    for (c in 1:ncol(x)){
        for ( r in 1:nrow(x)) {
           check <- is.na(x[r, c])
           if (check == TRUE){
               recipiente[r, c] <- FALSE}
                  else {
                      recipiente[r, c] <- TRUE}
              }
    }
    recipiente
    }

my_complete_cases <- function(x){ #restituisce se le colonne sono T o F
    recipiente <- matrix(NA, 1, ncol(x))
    tabella_logici <- my_complete_cases_pro(x)
    for (col in 1:ncol(tabella_logici)) {
        if(sum(tabella_logici[,col]) == nrow(tabella_logici)){
            recipiente[1, col] <- TRUE
        } else {
            recipiente[1, col] <- FALSE
        }
    }
    recipiente[1,]
}

#3.4.9 TROVIAMO GLI OUTLIER

is_outlier <- function(x, vettore){
    media <- mean(vettore)
    soglia_sotto_media <- media - sd(vettore)
    soglia_sopra_media <- media + sd(vettore)
    risultato <- dplyr::case_when(
        x < soglia_sotto_media ~ "TRUE",
        x > soglia_sopra_media ~ "TRUE",
        x >= soglia_sotto_media ~ "FALSE",
        x <= soglia_sopra_media ~ "FALSE",
        TRUE ~ "Errore") 
    as.logical(risultato)
}

has_outlier <- function(x){
    if (is.data.frame(x)) {
        risultato <- c()
        for (colonna in 1:ncol(x)) {
            if (is.numeric(x[, colonna])){
            risultato <- c(risultato, any(is_outlier(x[,colonna],x[,colonna])))}
            else {risultato <- c(risultato, NA)}}
        risultato
    } else {any(is_outlier(x,x))}
    }

my_mtcars <- mtcars
my_mtcars$factor1 <- factor(rep(c("a", "b", "c"), c(10, 10, 12)))
my_mtcars$factor2 <- rep(c("d", "e", "f"), c(10, 10, 12))
 
has_outlier(my_mtcars)

#3.4.10 BOOTSTRAPPING

prepare_bootstrap <- function(data, nrighe, n){
    if(is.data.frame(data)){
        lista_data_nuovi <- list(c())
        for (i in 1:n) {
            lista_data_nuovi[i] <- data[sample(1:nrow(data), nrighe), ]
        }
        lista_data_nuovi
    } else {print("Il vettore deve essere un data-frame")}
}

c <- list(prepare_bootstrap(cars, 10, 10))


for (i in 1:5) {
print(cars[sample(x = 1:nrow(cars), 2), ])
}

#Generazione di etichette univoche 
genera_etichette_univoche <- function(nEtichette, EtichettaPers = "A"){
    etichette_generate <- c()
    for (i in 1:nEtichette) {
        etichette_generate <- c(etichette_generate, paste(EtichettaPers, i, sep = ""))}
    etichette_generate    
}

#3.4.11 Leave-one-out
 #1
leave1out <- function(data, ColObs){
    if(is.data.frame(data)){
        lista_data_nuovi <- list(c())
        for (i in 1:nrow(data)){ 
            lista_data_nuovi[[i]] <- data[[ColObs]][-i]
        }
        names(lista_data_nuovi) <- genera_etichette_univoche(nrow(data), "SenzaItem")
        data.frame(lista_data_nuovi)
    } else {print("Il vettore deve essere un data-frame")}
}

leave1out_v2 <- function(data){ 
    if(is.data.frame(data)){
        lista_data_nuovi <- list()
        for (i in 1:nrow(data)){ 
            lista_data_nuovi[[i]] <- data[-i,]
        }
        lista_data_nuovi
    } else {print("Il vettore deve essere un data-frame")}
}


 #2




 #3

leave1out_with_remove <- function(data, ColObs, remove = 1){ #
    if(is.data.frame(data)){
        lista_data_nuovi <- list(c())
        for (i in 1:nrow(data)){ 
            lista_data_nuovi[[i]] <- data[[ColObs]][-i]
            lista_data_nuovi[[i]][sample(1:nrow(data)-1, remove)] <- NA
        }
        names(lista_data_nuovi) <- genera_etichette_univoche(nrow(data), "SenzaItem")
        data.frame(lista_data_nuovi)
    } else {print("Il vettore deve essere un data-frame")}
}
prova <- leave1out_with_remove(x, 2, 5)

#3.4.12 Popolare una matrice
x <- rnorm(100)
mat <- matrix(nrow = 10, ncol = 10)

popola_matrice <- function(my_mat, data){
    count <- 1
    popolata <- matrix(NA, nrow(my_mat), ncol(my_mat))
for (r in 1:nrow(my_mat)){
    for ( c in 1:ncol(my_mat)) {
        popolata[r, c] <- data[count]
        count <- count + 1
    }}
    popolata
    }
popola_matrice(mat, x)















